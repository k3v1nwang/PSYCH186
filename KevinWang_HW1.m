clear all
Randomize();
randSeed(1);
normDist();
Q3(1);
disp('e(2): ')
e(2)
disp('e(2): ')
e(3)
Q4(10000000);
%% Question 1 

function[h1] = Randomize()
   group_size = 50000;
   disp('Randomize() histogram: ')
   rng('shuffle') 
   randNums = rand(1, group_size);
   sorted = sort(randNums);
   figure('Name', 'Randomize()'); 
   h1 = histogram(sorted);
   h1.NumBins = 10;
   h1.FaceColor = 'r';
        
end
  function [h3] = randSeed(s)
    %   RANDSEED Generates set of 50,000 doubles with passed in seed value
    seed = s;
    rng(s);
    disp('seed:')
    disp(seed)
    randNums = rand(1, 50000);
    sorted = sort(randNums);
    sNum = string(seed);
    nameT = strcat('RandSeed(', sNum,')');
    figure('Name', nameT); 
    h3 = histogram(sorted);
    h3.NumBins = 10;
    h3.FaceColor = 'g';  
  end
  %%
%%Question 2
 function [h2,h4] = normDist()
    %Q2 creates a Gassian distribution of randomly generated numbers
    %   Detailed explanation goes here
    vals = randn(1, 50000);
    figure('Name', 'normDist() with curve')
    h4 = histfit(vals);
    figure('Name', 'normDist()')
    h2 = histogram(vals);
    h2.NumBins = 10;
    %the results returned by adtest shows if it passes the Anderson-Darling
    %Test a logical = 0 means that it fails to reject the hypothesis that
    %it is NOT normally distributed, the p values gives the probability
    [q,p] = adtest(vals);
    pString = string(p);
    p_val = strcat('p-value: ', pString);
    
    if(q ==0)
      disp('The data is normally distributed') 
      disp(p_val)
    end
 end

 
 %%
 %%Question 3
 function [v,m,sd,h] = Q3(n)
%Q3 Summary of this function goes here
%   Detailed explanation goes here
    nCycles = n;
    v = zeros(1,8);
    m = zeros(1,8);
    sd = zeros(1,8);
    h = zeros(1,8);
    for vi = 1:nCycles
        for d = [10,20,50,100,250,500,1000,2000]
            output = strcat("Dimensions: ", string(d));
            disp(output)
            x = randn(d);
            y = randn(d);
            x = x/norm(x);
            y = y/norm(y);
            %normalize values
            while norm(x) ~= 1
                x = randn(d);
                x = x/norm(x);
                if norm(x) == 1
                    break;
                end
            end
            while norm(y) ~= 1
                y = randn(d);
                y = y/norm(y);
                if norm(y) == 1
                    break;
                end
            end
            dimension = d; 
            v = dot(x,y);
            %storing the results in seperate vectors, correlating the
            %dimension to the index of the answer (10,20,etc to 1,2,3,etc)
            for i = [1,2,3,4,5,6,7,8]
                switch (dimension) 
                    case 10
                        index =1;
                    case 20
                        index =2;
                    case 50
                        index =3;
                    case 100
                        index =4;
                    case 250
                        index =5;
                    case 500
                        index =6;
                    case 1000
                        index =7;
                    case 2000
                        index =8;
                end
                %v(index) = dot(x,y);
                m(index) = mean(v);
                sd(index) = std(v);
                h(index) = histogram(v);
            end
            %(a) :geometrically, the dot product is the scalar magnitudes of two vectors and the
            %cosine of the angle between them.
            %output mean and sd
            disp('mean: ')
            v_mean = mean(v);
            disp(v_mean)
            disp('sd: ')
            v_sd =std(v);
            disp(v_sd)
            %%output histograms
            XD = strcat(string(d), '-D');
            figure('Name', XD);
            histogram(v);
        end 
    end
    %%(C): the mean should be centered around 0 because the vectors are
    %%generated by randn() function that has a normal distribution of
    %values and because the random values are normalized by x = x/norm(x) and
    %%y = y/norm(y) to satisfy the constraints of a unit vector, as more
    %%dimensions are added, more values are generated closer to the mean of
    %%0 (for the dot product) by the central limit theorem.
    
    disp('mean vector');
    disp(m);
    disp('sd vector');
    disp(sd);
    figure;
    dim = [10,20,50,100,250,500,1000,2000];
    plot(dim,sd);       %this plot shows the trend of standard devisions after shifting the dimensionality
end
 %%(D) compute expected standard deviations
function [sem] = e(x)
%E predicts expected SEM (standard error from the mean) from a given dimmension
%   typing in e(2) gives estimate for 2D, e(3) gives estimate for 3D,
%   e(1000) give estimate for 1000D, etc
    E = sqrt(pi);     %from error function  
    size = (x)^2;
    a = E*(x^2);
    b = (E * x)^2;
    y = a - b;
    y = abs(y);
    sd = sqrt(y);
    sem = sd/(size);
end


%%
 %%Question 4
function [pi_val] = Q4(n)
%Q4(n) calculates the crude value of pi
%  counts the number of times the random x,y coords land within the radius
%  of a unit circle, then calculates value of pi from (pi/4)/n trials
    trials = n;
    z = 0;
    for ii = 1:trials
        x = rand();     %rand val from uniform dist
        y = rand();
        if((x*x + y*y)<=1)
            z = z +1;       %increment z when the values land within circle
        end
    end
    pi_val = (4.0*z)/trials;
    msg = strcat("pi approximation with ", num2str(trials), " trials = ");
    disp(msg);
    disp(pi_val);
end
%%

%%Question 5
%A total of about 20 hours was put into this homework assignment
